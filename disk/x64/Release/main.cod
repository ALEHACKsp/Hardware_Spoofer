; Listing generated by Microsoft (R) Optimizing Compiler Version 19.14.26429.4 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_DATA	SEGMENT
COMM	DeviceObject:QWORD
COMM	dev:BYTE:010H
COMM	dos:BYTE:010H
COMM	PID:DWORD
COMM	MainModule:QWORD
COMM	process:QWORD
_DATA	ENDS
PUBLIC	DriverUnload
PUBLIC	RPM
PUBLIC	WPM
PUBLIC	DriverDispatch
PUBLIC	DriverEntry
PUBLIC	??_C@_1BK@DMJFENL@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAA?$AAs?$AAu?$AAs?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
PUBLIC	??_C@_1CC@FCIJJCAF@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAA?$AAs?$AAu?$AAs?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	__imp_RtlInitUnicodeString:PROC
EXTRN	__imp_ProbeForRead:PROC
EXTRN	__imp_ProbeForWrite:PROC
EXTRN	__imp_IofCompleteRequest:PROC
EXTRN	__imp_IoCreateDevice:PROC
EXTRN	__imp_IoCreateSymbolicLink:PROC
EXTRN	__imp_IoDeleteDevice:PROC
EXTRN	__imp_IoDeleteSymbolicLink:PROC
EXTRN	__imp_IoGetCurrentProcess:PROC
EXTRN	__imp_KeAttachProcess:PROC
EXTRN	__imp_KeDetachProcess:PROC
EXTRN	__imp_PsLookupProcessByProcessId:PROC
EXTRN	MmCopyVirtualMemory:PROC
EXTRN	__imp_PsGetProcessSectionBaseAddress:PROC
EXTRN	__C_specific_handler:PROC
;	COMDAT pdata
pdata	SEGMENT
$pdata$DriverUnload DD imagerel $LN4
	DD	imagerel $LN4+40
	DD	imagerel $unwind$DriverUnload
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$RPM DD	imagerel $LN12
	DD	imagerel $LN12+119
	DD	imagerel $unwind$RPM
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$WPM DD	imagerel $LN12
	DD	imagerel $LN12+122
	DD	imagerel $unwind$WPM
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DriverDispatch DD imagerel $LN15
	DD	imagerel $LN15+285
	DD	imagerel $unwind$DriverDispatch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DriverEntry DD imagerel $LN4
	DD	imagerel $LN4+203
	DD	imagerel $unwind$DriverEntry
pdata	ENDS
;	COMDAT ??_C@_1CC@FCIJJCAF@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAA?$AAs?$AAu?$AAs?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1CC@FCIJJCAF@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAA?$AAs?$AAu?$AAs?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'o', 00H, 's', 00H, 'D', 00H, 'e', 00H, 'v', 00H
	DB	'i', 00H, 'c', 00H, 'e', 00H, 's', 00H, '\', 00H, 'A', 00H, 's'
	DB	00H, 'u', 00H, 's', 00H, 00H, 00H		;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT ??_C@_1BK@DMJFENL@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAA?$AAs?$AAu?$AAs?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BK@DMJFENL@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAA?$AAs?$AAu?$AAs?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'e', 00H, 'v', 00H, 'i', 00H, 'c', 00H, 'e', 00H
	DB	'\', 00H, 'A', 00H, 's', 00H, 'u', 00H, 's', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DriverEntry DD 040602H
	DD	06001602H
	DD	030027206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DriverDispatch DD 060a02H
	DD	06001602H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$WPM DD	080f0aH
	DD	06001602H
	DD	0b640fH
	DD	0a340fH
	DD	0700b720fH
	DD	imagerel __C_specific_handler
	DD	01H
	DD	imagerel $LN12+24
	DD	imagerel $LN12+101
	DD	01H
	DD	imagerel $LN12+101
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$RPM DD	080f0aH
	DD	06001602H
	DD	0b640fH
	DD	0a340fH
	DD	0700b720fH
	DD	imagerel __C_specific_handler
	DD	01H
	DD	imagerel $LN12+24
	DD	imagerel $LN12+98
	DD	01H
	DD	imagerel $LN12+98
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DriverUnload DD 040602H
	DD	06001602H
	DD	030023206H
xdata	ENDS
; Function compile flags: /Ogsp
; File c:\users\finn\documents\github\hwidfaker\disk\main.c
;	COMDAT DriverEntry
_TEXT	SEGMENT
DriverObject$ = 80
RegistryPath$ = 88
DriverEntry PROC					; COMDAT

; 204  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 205  : 	// This will only help with shitty kernel anti cheats since most of them can easily enumerate all the modules and find this lonely boy
; 206  : 	// Get our drivers entry and the entries for drivers before ours and after ours
; 207  : 	PLDR_DATA_TABLE_ENTRY CurDriverEntry = (PLDR_DATA_TABLE_ENTRY)DriverObject->DriverSection;

  00006	4c 8b 41 28	 mov	 r8, QWORD PTR [rcx+40]
  0000a	48 8b d9	 mov	 rbx, rcx

; 208  : 	PLDR_DATA_TABLE_ENTRY NextDriverEntry = (PLDR_DATA_TABLE_ENTRY)CurDriverEntry->InLoadOrderLinks.Flink;
; 209  : 	PLDR_DATA_TABLE_ENTRY PrevDriverEntry = (PLDR_DATA_TABLE_ENTRY)CurDriverEntry->InLoadOrderLinks.Blink;
; 210  : 
; 211  : 	// Change the entries of the prevoius and the next driver to basically skip our driver
; 212  : 	PrevDriverEntry->InLoadOrderLinks.Flink = CurDriverEntry->InLoadOrderLinks.Flink;
; 213  : 	NextDriverEntry->InLoadOrderLinks.Blink = CurDriverEntry->InLoadOrderLinks.Blink;
; 214  : 
; 215  : 	// Make our driver lonely...
; 216  : 	CurDriverEntry->InLoadOrderLinks.Flink = (PLIST_ENTRY)CurDriverEntry;
; 217  : 	CurDriverEntry->InLoadOrderLinks.Blink = (PLIST_ENTRY)CurDriverEntry;
; 218  : 
; 219  : 	// Our device and symbolic link names
; 220  : 	RtlInitUnicodeString(&dev, L"\\Device\\Asus");

  0000d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dev
  00014	49 8b 40 08	 mov	 rax, QWORD PTR [r8+8]
  00018	49 8b 10	 mov	 rdx, QWORD PTR [r8]
  0001b	48 89 10	 mov	 QWORD PTR [rax], rdx
  0001e	49 8b 40 08	 mov	 rax, QWORD PTR [r8+8]
  00022	48 89 42 08	 mov	 QWORD PTR [rdx+8], rax
  00026	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1BK@DMJFENL@?$AA?2?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AA?2?$AAA?$AAs?$AAu?$AAs?$AA?$AA@FNODOBFM@
  0002d	4d 89 00	 mov	 QWORD PTR [r8], r8
  00030	4d 89 40 08	 mov	 QWORD PTR [r8+8], r8
  00034	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 221  : 	RtlInitUnicodeString(&dos, L"\\DosDevices\\Asus");

  0003a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1CC@FCIJJCAF@?$AA?2?$AAD?$AAo?$AAs?$AAD?$AAe?$AAv?$AAi?$AAc?$AAe?$AAs?$AA?2?$AAA?$AAs?$AAu?$AAs?$AA?$AA@FNODOBFM@
  00041	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dos
  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 222  : 
; 223  : 	// Create our device and symbolic link
; 224  : 	IoCreateDevice(DriverObject, 0, &dev, FILE_DEVICE_UNKNOWN, FILE_DEVICE_SECURE_OPEN, FALSE, &DeviceObject);

  0004e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:DeviceObject
  00055	41 b9 22 00 00
	00		 mov	 r9d, 34			; 00000022H
  0005b	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00060	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:dev
  00067	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  0006c	33 d2		 xor	 edx, edx
  0006e	48 8b cb	 mov	 rcx, rbx
  00071	c7 44 24 20 00
	01 00 00	 mov	 DWORD PTR [rsp+32], 256	; 00000100H
  00079	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoCreateDevice

; 225  : 	IoCreateSymbolicLink(&dos, &dev);

  0007f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:dev
  00086	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dos
  0008d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoCreateSymbolicLink

; 226  : 
; 227  : 	// Used for IO control and when driver is unloaded
; 228  : 	DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = DriverDispatch;

  00093	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:DriverDispatch
  0009a	48 89 83 e0 00
	00 00		 mov	 QWORD PTR [rbx+224], rax

; 229  : 	DriverObject->DriverUnload = DriverUnload;

  000a1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:DriverUnload
  000a8	48 89 43 68	 mov	 QWORD PTR [rbx+104], rax

; 230  : 
; 231  : 	// It won't work if you remove, so don't touch it!!!
; 232  : 	DeviceObject->Flags |= DO_DIRECT_IO;

  000ac	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR DeviceObject
  000b3	83 48 30 10	 or	 DWORD PTR [rax+48], 16

; 233  : 	DeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

  000b7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR DeviceObject
  000be	0f ba 70 30 07	 btr	 DWORD PTR [rax+48], 7

; 234  : 
; 235  : 	return STATUS_SUCCESS;

  000c3	33 c0		 xor	 eax, eax

; 236  : }

  000c5	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000c9	5b		 pop	 rbx
  000ca	c3		 ret	 0
DriverEntry ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File c:\users\finn\documents\github\hwidfaker\disk\main.c
;	COMDAT DriverDispatch
_TEXT	SEGMENT
pDeviceObject$ = 48
Irp$ = 56
DriverDispatch PROC					; COMDAT

; 132  : {

$LN15:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 133  : 	NTSTATUS status = STATUS_SUCCESS;
; 134  : 	ULONG bytes = 0;
; 135  : 
; 136  : 	PIO_STACK_LOCATION stack = IoGetCurrentIrpStackLocation(Irp);
; 137  : 
; 138  : 	// Get the IOCTL code
; 139  : 	ULONG IOcode = stack->Parameters.DeviceIoControl.IoControlCode;

  0000a	48 8b 82 b8 00
	00 00		 mov	 rax, QWORD PTR [rdx+184]
  00011	48 8b fa	 mov	 rdi, rdx
  00014	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]

; 140  : 
; 141  : 	if (IOcode == READ_REQUEST)

  00017	81 f9 00 20 22
	00		 cmp	 ecx, 2236416		; 00222000H
  0001d	75 3f		 jne	 SHORT $LN2@DriverDisp

; 142  : 	{
; 143  : 		// Get the struct address from the irp buffer
; 144  : 		PREAD_MEM read = (PREAD_MEM)Irp->AssociatedIrp.SystemBuffer;

  0001f	48 8b 5a 18	 mov	 rbx, QWORD PTR [rdx+24]

; 145  : 
; 146  : 		// Check if address is in usermode virtual memory (the usermode app sometimes fuck up for some reason)
; 147  : 		if (read->address < 0x7FFFFFFFFFFF)

  00023	48 b8 ff ff ff
	ff ff 7f 00 00	 mov	 rax, 140737488355327	; 00007fffffffffffH
  0002d	48 39 03	 cmp	 QWORD PTR [rbx], rax
  00030	0f 83 c2 00 00
	00		 jae	 $LN4@DriverDisp

; 148  : 		{
; 149  : 			PsLookupProcessByProcessId((HANDLE)PID, &process);

  00036	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR PID
  0003c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:process
  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsLookupProcessByProcessId

; 150  : 			RPM(read->address, &read->response, read->size);

  00049	44 8b 43 10	 mov	 r8d, DWORD PTR [rbx+16]
  0004d	48 8d 53 08	 lea	 rdx, QWORD PTR [rbx+8]
  00051	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00054	e8 00 00 00 00	 call	 RPM

; 151  : 		}
; 152  : 
; 153  : 		status = STATUS_SUCCESS;
; 154  : 		bytes = sizeof(PREAD_MEM);
; 155  : 	}

  00059	e9 9a 00 00 00	 jmp	 $LN4@DriverDisp
$LN2@DriverDisp:

; 156  : 	else if (IOcode == WRITE_REQUEST)

  0005e	81 f9 04 20 22
	00		 cmp	 ecx, 2236420		; 00222004H
  00064	75 38		 jne	 SHORT $LN5@DriverDisp

; 157  : 	{
; 158  : 		// Get the struct address from the irp buffer
; 159  : 		PWRITE_MEM write = (PWRITE_MEM)Irp->AssociatedIrp.SystemBuffer;

  00066	48 8b 5a 18	 mov	 rbx, QWORD PTR [rdx+24]

; 160  : 
; 161  : 		// Check if address is in usermode virtual memory (the usermode app sometimes fuck up for some reason)
; 162  : 		if (write->address < 0x7FFFFFFFFFFF)

  0006a	48 b8 ff ff ff
	ff ff 7f 00 00	 mov	 rax, 140737488355327	; 00007fffffffffffH
  00074	48 39 03	 cmp	 QWORD PTR [rbx], rax
  00077	73 7f		 jae	 SHORT $LN4@DriverDisp

; 163  : 		{
; 164  : 			PsLookupProcessByProcessId((HANDLE)PID, &process);

  00079	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR PID
  0007f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:process
  00086	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsLookupProcessByProcessId

; 165  : 			WPM(&write->value, write->address, write->size);

  0008c	44 8b 43 0c	 mov	 r8d, DWORD PTR [rbx+12]
  00090	48 8d 4b 08	 lea	 rcx, QWORD PTR [rbx+8]
  00094	48 8b 13	 mov	 rdx, QWORD PTR [rbx]
  00097	e8 00 00 00 00	 call	 WPM

; 166  : 		}
; 167  : 
; 168  : 		status = STATUS_SUCCESS;
; 169  : 		bytes = sizeof(PWRITE_MEM);
; 170  : 	}

  0009c	eb 5a		 jmp	 SHORT $LN4@DriverDisp
$LN5@DriverDisp:

; 171  : 	else if (IOcode == SET_PID_REQUEST)

  0009e	81 f9 08 20 22
	00		 cmp	 ecx, 2236424		; 00222008H
  000a4	75 0e		 jne	 SHORT $LN8@DriverDisp

; 172  : 	{
; 173  : 		// Get address of var where to read the PID from
; 174  : 		PULONG Input = (PULONG)Irp->AssociatedIrp.SystemBuffer;

  000a6	48 8b 42 18	 mov	 rax, QWORD PTR [rdx+24]

; 175  : 		PID = *Input;

  000aa	8b 08		 mov	 ecx, DWORD PTR [rax]
  000ac	89 0d 00 00 00
	00		 mov	 DWORD PTR PID, ecx

; 176  : 
; 177  : 		status = STATUS_SUCCESS;
; 178  : 		bytes = sizeof(Input);
; 179  : 	}

  000b2	eb 44		 jmp	 SHORT $LN4@DriverDisp
$LN8@DriverDisp:

; 180  : 	else if (IOcode == GET_MODULE_REQUEST)

  000b4	33 c0		 xor	 eax, eax
  000b6	81 f9 0c 20 22
	00		 cmp	 ecx, 2236428		; 0022200cH
  000bc	75 3f		 jne	 SHORT $LN10@DriverDisp

; 181  : 	{
; 182  : 		// Get address of var where to store the main mdoule base address
; 183  : 		PDWORD64 Module = (PDWORD64)Irp->AssociatedIrp.SystemBuffer;

  000be	48 8b 5a 18	 mov	 rbx, QWORD PTR [rdx+24]

; 184  : 		PsLookupProcessByProcessId((HANDLE)PID, &process);

  000c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:process
  000c9	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR PID
  000cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsLookupProcessByProcessId

; 185  : 
; 186  : 		// Attach to the process and get it's base
; 187  : 		KeAttachProcess((PKPROCESS)process);

  000d5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR process
  000dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeAttachProcess

; 188  : 		*Module = PsGetProcessSectionBaseAddress(process);

  000e2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR process
  000e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PsGetProcessSectionBaseAddress
  000ef	48 89 03	 mov	 QWORD PTR [rbx], rax

; 189  : 		KeDetachProcess();

  000f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeDetachProcess
$LN4@DriverDisp:

; 190  : 
; 191  : 		status = STATUS_SUCCESS;
; 192  : 		bytes = sizeof(Module);
; 193  : 	}
; 194  : 
; 195  : 	// Finish our request
; 196  : 	Irp->IoStatus.Status = status;

  000f8	b8 08 00 00 00	 mov	 eax, 8
$LN10@DriverDisp:
  000fd	83 67 30 00	 and	 DWORD PTR [rdi+48], 0

; 197  : 	Irp->IoStatus.Information = bytes;
; 198  : 	IoCompleteRequest(Irp, IO_NO_INCREMENT);

  00101	33 d2		 xor	 edx, edx
  00103	48 8b cf	 mov	 rcx, rdi
  00106	48 89 47 38	 mov	 QWORD PTR [rdi+56], rax
  0010a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest

; 199  : 
; 200  : 	return status;
; 201  : }

  00110	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00115	33 c0		 xor	 eax, eax
  00117	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0011b	5f		 pop	 rdi
  0011c	c3		 ret	 0
DriverDispatch ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File c:\users\finn\documents\github\hwidfaker\disk\main.c
;	COMDAT WPM
_TEXT	SEGMENT
src$ = 80
dest$ = 88
size$ = 96
bytes$ = 104
WPM	PROC						; COMDAT

; 113  : {

$LN12:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	49 8b d8	 mov	 rbx, r8
  00012	48 8b fa	 mov	 rdi, rdx
  00015	48 8b f1	 mov	 rsi, rcx

; 114  : 	PSIZE_T bytes;
; 115  : 	__try
; 116  : 	{
; 117  : 		// Checks if the memory address actually exists and is writable
; 118  : 		ProbeForWrite(dest, size, (ULONG)size);

  00018	44 8b c3	 mov	 r8d, ebx
  0001b	48 8b d3	 mov	 rdx, rbx
  0001e	48 8b cf	 mov	 rcx, rdi
  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ProbeForWrite

; 119  : 		// Use MmCopyVirtualMemory to copy memory from our usermode process to the game
; 120  : 		if (NT_SUCCESS(MmCopyVirtualMemory(PsGetCurrentProcess(), src, process, dest, size, KernelMode, &bytes)))

  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoGetCurrentProcess
  0002d	48 8b c8	 mov	 rcx, rax
  00030	48 8d 44 24 68	 lea	 rax, QWORD PTR bytes$[rsp]
  00035	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  0003a	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  0003f	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00044	4c 8b cf	 mov	 r9, rdi
  00047	4c 8b 05 00 00
	00 00		 mov	 r8, QWORD PTR process
  0004e	48 8b d6	 mov	 rdx, rsi
  00051	e8 00 00 00 00	 call	 MmCopyVirtualMemory
  00056	85 c0		 test	 eax, eax
  00058	78 04		 js	 SHORT $LN3@WPM

; 121  : 			return STATUS_SUCCESS;

  0005a	33 c0		 xor	 eax, eax
  0005c	eb 0c		 jmp	 SHORT $LN10@WPM
$LN3@WPM:

; 122  : 		else
; 123  : 			return STATUS_ACCESS_DENIED;

  0005e	b8 22 00 00 c0	 mov	 eax, -1073741790	; ffffffffc0000022H
  00063	eb 05		 jmp	 SHORT $LN10@WPM
$LN8@WPM:

; 124  : 	}
; 125  : 	__except (EXCEPTION_EXECUTE_HANDLER)
; 126  : 	{
; 127  : 		return STATUS_ACCESS_DENIED;

  00065	b8 22 00 00 c0	 mov	 eax, -1073741790	; ffffffffc0000022H
$LN10@WPM:

; 128  : 	}
; 129  : }

  0006a	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0006f	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  00074	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00078	5f		 pop	 rdi
  00079	c3		 ret	 0
WPM	ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File c:\users\finn\documents\github\hwidfaker\disk\main.c
;	COMDAT RPM
_TEXT	SEGMENT
src$ = 80
dest$ = 88
size$ = 96
bytes$ = 104
RPM	PROC						; COMDAT

; 94   : {

$LN12:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	49 8b d8	 mov	 rbx, r8
  00012	48 8b f2	 mov	 rsi, rdx
  00015	48 8b f9	 mov	 rdi, rcx

; 95   : 	PSIZE_T bytes;
; 96   : 	__try
; 97   : 	{
; 98   : 		// Checks if the memory address actually exists
; 99   : 		ProbeForRead(src, size, (ULONG)size);

  00018	44 8b c3	 mov	 r8d, ebx
  0001b	48 8b d3	 mov	 rdx, rbx
  0001e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ProbeForRead

; 100  : 		// Use MmCopyVirtualMemory to copy memory from the game to our usermode process
; 101  : 		if (NT_SUCCESS(MmCopyVirtualMemory(process, src, PsGetCurrentProcess(), dest, size, KernelMode, &bytes)))

  00024	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoGetCurrentProcess
  0002a	4c 8b c0	 mov	 r8, rax
  0002d	48 8d 44 24 68	 lea	 rax, QWORD PTR bytes$[rsp]
  00032	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00037	c6 44 24 28 00	 mov	 BYTE PTR [rsp+40], 0
  0003c	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00041	4c 8b ce	 mov	 r9, rsi
  00044	48 8b d7	 mov	 rdx, rdi
  00047	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR process
  0004e	e8 00 00 00 00	 call	 MmCopyVirtualMemory
  00053	85 c0		 test	 eax, eax
  00055	78 04		 js	 SHORT $LN3@RPM

; 102  : 			return STATUS_SUCCESS;

  00057	33 c0		 xor	 eax, eax
  00059	eb 0c		 jmp	 SHORT $LN10@RPM
$LN3@RPM:

; 103  : 		else
; 104  : 			return STATUS_ACCESS_DENIED;

  0005b	b8 22 00 00 c0	 mov	 eax, -1073741790	; ffffffffc0000022H
  00060	eb 05		 jmp	 SHORT $LN10@RPM
$LN8@RPM:

; 105  : 	}
; 106  : 	__except (EXCEPTION_EXECUTE_HANDLER)
; 107  : 	{
; 108  : 		return STATUS_ACCESS_DENIED;

  00062	b8 22 00 00 c0	 mov	 eax, -1073741790	; ffffffffc0000022H
$LN10@RPM:

; 109  : 	}
; 110  : }

  00067	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  0006c	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
  00071	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00075	5f		 pop	 rdi
  00076	c3		 ret	 0
RPM	ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File c:\users\finn\documents\github\hwidfaker\disk\main.c
;	COMDAT DriverUnload
_TEXT	SEGMENT
DriverObject$ = 48
DriverUnload PROC					; COMDAT

; 241  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 242  : 	// Clean up after us
; 243  : 	IoDeleteSymbolicLink(&dos);

  00009	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:dos
  00010	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDeleteSymbolicLink

; 244  : 	IoDeleteDevice(DriverObject->DeviceObject);

  00016	48 8b 4b 08	 mov	 rcx, QWORD PTR [rbx+8]
  0001a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IoDeleteDevice

; 245  : 
; 246  : 	return STATUS_SUCCESS;

  00020	33 c0		 xor	 eax, eax

; 247  : }

  00022	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00026	5b		 pop	 rbx
  00027	c3		 ret	 0
DriverUnload ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\km\wdm.h
;	COMDAT IoGetCurrentIrpStackLocation
_TEXT	SEGMENT
Irp$ = 8
IoGetCurrentIrpStackLocation PROC			; COMDAT

; 30867:     NT_ASSERT(Irp->CurrentLocation <= Irp->StackCount + 1);
; 30868:     return Irp->Tail.Overlay.CurrentStackLocation;

  00000	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]

; 30869: }

  00007	c3		 ret	 0
IoGetCurrentIrpStackLocation ENDP
_TEXT	ENDS
END
