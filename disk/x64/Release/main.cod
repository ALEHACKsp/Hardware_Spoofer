; Listing generated by Microsoft (R) Optimizing Compiler Version 19.14.26429.4 

include listing.inc

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	RealDiskDeviceControl
PUBLIC	NumTable
PUBLIC	SpoofedHWID
PUBLIC	HWIDGenerated
_BSS	SEGMENT
RealDiskDeviceControl DQ 01H DUP (?)
HWIDGenerated DD 01H DUP (?)
_BSS	ENDS
_DATA	SEGMENT
NumTable DB	'123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ', 00H
	ORG $+4
SpoofedHWID DB	'SYSTEM', 00H, 00H
_DATA	ENDS
PUBLIC	GetDriverObject
PUBLIC	SpoofSerialNumber
PUBLIC	StorageQueryCompletionRoutine
PUBLIC	SmartCompletionRoutine
PUBLIC	DiskDriverDispatch
PUBLIC	UnsupportedDispatch
PUBLIC	CreateDispatch
PUBLIC	CloseDispatch
PUBLIC	DriverEntry
PUBLIC	??_C@_1BK@NMHHIFPM@?$AA?2?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?2?$AAd?$AAi?$AAs?$AAk?$AA?$AA@FNODOBFM@ ;  ?? ::FNODOBFM::`string'
EXTRN	__imp_RtlInitUnicodeString:PROC
EXTRN	__imp_KeQuerySystemTimePrecise:PROC
EXTRN	__imp_ExAllocatePool:PROC
EXTRN	__imp_ExFreePoolWithTag:PROC
EXTRN	__imp_IofCompleteRequest:PROC
EXTRN	__imp_RtlRandomEx:PROC
EXTRN	__imp_ObReferenceObjectByName:PROC
EXTRN	__imp_IoDriverObjectType:QWORD
;	COMDAT pdata
pdata	SEGMENT
$pdata$GetDriverObject DD imagerel $LN5
	DD	imagerel $LN5+74
	DD	imagerel $unwind$GetDriverObject
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$SpoofSerialNumber DD imagerel $LN19
	DD	imagerel $LN19+280
	DD	imagerel $unwind$SpoofSerialNumber
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$StorageQueryCompletionRoutine DD imagerel $LN7
	DD	imagerel $LN7+137
	DD	imagerel $unwind$StorageQueryCompletionRoutine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$SmartCompletionRoutine DD imagerel $LN5
	DD	imagerel $LN5+39
	DD	imagerel $unwind$SmartCompletionRoutine
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DiskDriverDispatch DD imagerel $LN12
	DD	imagerel $LN12+198
	DD	imagerel $unwind$DiskDriverDispatch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$UnsupportedDispatch DD imagerel $LN4
	DD	imagerel $LN4+36
	DD	imagerel $unwind$UnsupportedDispatch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CreateDispatch DD imagerel $LN4
	DD	imagerel $LN4+29
	DD	imagerel $unwind$CreateDispatch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$CloseDispatch DD imagerel $LN4
	DD	imagerel $LN4+29
	DD	imagerel $unwind$CloseDispatch
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$DriverEntry DD imagerel $LN4
	DD	imagerel $LN4+117
	DD	imagerel $unwind$DriverEntry
pdata	ENDS
;	COMDAT ??_C@_1BK@NMHHIFPM@?$AA?2?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?2?$AAd?$AAi?$AAs?$AAk?$AA?$AA@FNODOBFM@
text$s	SEGMENT
??_C@_1BK@NMHHIFPM@?$AA?2?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?2?$AAd?$AAi?$AAs?$AAk?$AA?$AA@FNODOBFM@ DB '\'
	DB	00H, 'D', 00H, 'r', 00H, 'i', 00H, 'v', 00H, 'e', 00H, 'r', 00H
	DB	'\', 00H, 'd', 00H, 'i', 00H, 's', 00H, 'k', 00H, 00H, 00H ;  ?? ::FNODOBFM::`string'
text$s	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DriverEntry DD 060a02H
	DD	06001602H
	DD	08340aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CloseDispatch DD 040602H
	DD	06001602H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$CreateDispatch DD 040602H
	DD	06001602H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$UnsupportedDispatch DD 040602H
	DD	06001602H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$DiskDriverDispatch DD 0a1402H
	DD	06001608H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SmartCompletionRoutine DD 040602H
	DD	06001602H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$StorageQueryCompletionRoutine DD 0c1802H
	DD	06001606H
	DD	0a6418H
	DD	095418H
	DD	083418H
	DD	0f0143218H
	DD	07010e012H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$SpoofSerialNumber DD 0c1902H
	DD	06001607H
	DD	0b7419H
	DD	0a6419H
	DD	083419H
	DD	0f0153219H
	DD	0c011e013H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$GetDriverObject DD 040802H
	DD	06001602H
	DD	030047208H
xdata	ENDS
; Function compile flags: /Ogsp
; File c:\users\finn\documents\github\hardware_spoofer\disk\main.c
;	COMDAT DriverEntry
_TEXT	SEGMENT
diskDrvName$ = 32
DriverObject$ = 64
RegistryPath$ = 72
DriverEntry PROC					; COMDAT

; 207  : {

$LN4:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b fa	 mov	 rdi, rdx
  0000d	48 8b d9	 mov	 rbx, rcx

; 208  : 	NTSTATUS        status = STATUS_SUCCESS;
; 209  : 
; 210  : 	UNICODE_STRING diskDrvName;
; 211  : 	RtlInitUnicodeString(&diskDrvName, L"\\Driver\\disk");

  00010	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_1BK@NMHHIFPM@?$AA?2?$AAD?$AAr?$AAi?$AAv?$AAe?$AAr?$AA?2?$AAd?$AAi?$AAs?$AAk?$AA?$AA@FNODOBFM@
  00017	48 8d 4c 24 20	 lea	 rcx, QWORD PTR diskDrvName$[rsp]
  0001c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlInitUnicodeString

; 212  : 
; 213  : 	PDRIVER_OBJECT diskDrvObj = GetDriverObject(&diskDrvName);

  00022	48 8d 4c 24 20	 lea	 rcx, QWORD PTR diskDrvName$[rsp]
  00027	e8 00 00 00 00	 call	 GetDriverObject

; 214  : 
; 215  : 	RealDiskDeviceControl = diskDrvObj->MajorFunction[IRP_MJ_DEVICE_CONTROL];
; 216  : 
; 217  : 	diskDrvObj->DriverInit = &DriverEntry;

  0002c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:DriverEntry
  00033	4c 8b 80 e0 00
	00 00		 mov	 r8, QWORD PTR [rax+224]
  0003a	4c 89 05 00 00
	00 00		 mov	 QWORD PTR RealDiskDeviceControl, r8
  00041	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 218  : 	diskDrvObj->DriverStart = (PVOID)DriverObject;
; 219  : 	diskDrvObj->DriverSize = (ULONG)RegistryPath;
; 220  : 	diskDrvObj->FastIoDispatch = NULL;

  00045	33 c9		 xor	 ecx, ecx
  00047	48 89 48 50	 mov	 QWORD PTR [rax+80], rcx

; 221  : 	diskDrvObj->DriverStartIo = NULL;

  0004b	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx

; 222  : 	diskDrvObj->DriverUnload = NULL;

  0004f	48 89 48 68	 mov	 QWORD PTR [rax+104], rcx

; 223  : 
; 224  : 	/*for (ULONG t = 0; t <= IRP_MJ_MAXIMUM_FUNCTION; t++)
; 225  : 	diskDrvObj->MajorFunction[t] = &UnsupportedDispatch;*/
; 226  : 
; 227  : 	diskDrvObj->MajorFunction[IRP_MJ_DEVICE_CONTROL] = &DiskDriverDispatch;

  00053	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:DiskDriverDispatch
  0005a	48 89 58 18	 mov	 QWORD PTR [rax+24], rbx

; 228  : 	/*diskDrvObj->MajorFunction[IRP_MJ_CREATE] = &CreateDispatch;
; 229  : 	diskDrvObj->MajorFunction[IRP_MJ_CLOSE] = &CloseDispatch;*/
; 230  : 
; 231  : 	return status;
; 232  : }

  0005e	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00063	48 89 88 e0 00
	00 00		 mov	 QWORD PTR [rax+224], rcx
  0006a	89 78 20	 mov	 DWORD PTR [rax+32], edi
  0006d	33 c0		 xor	 eax, eax
  0006f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00073	5f		 pop	 rdi
  00074	c3		 ret	 0
DriverEntry ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File c:\users\finn\documents\github\hardware_spoofer\disk\main.c
;	COMDAT CloseDispatch
_TEXT	SEGMENT
DeviceObject$ = 48
Irp$ = 56
CloseDispatch PROC					; COMDAT

; 199  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b da	 mov	 rbx, rdx

; 200  : 	UNREFERENCED_PARAMETER(DeviceObject);
; 201  : 
; 202  : 	IoCompleteRequest(Irp, IO_NO_INCREMENT);

  00009	33 d2		 xor	 edx, edx
  0000b	48 8b cb	 mov	 rcx, rbx
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest

; 203  : 	return Irp->IoStatus.Status;

  00014	8b 43 30	 mov	 eax, DWORD PTR [rbx+48]

; 204  : }

  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5b		 pop	 rbx
  0001c	c3		 ret	 0
CloseDispatch ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File c:\users\finn\documents\github\hardware_spoofer\disk\main.c
;	COMDAT CreateDispatch
_TEXT	SEGMENT
DeviceObject$ = 48
Irp$ = 56
CreateDispatch PROC					; COMDAT

; 190  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b da	 mov	 rbx, rdx

; 191  : 	UNREFERENCED_PARAMETER(DeviceObject);
; 192  : 
; 193  : 	IoCompleteRequest(Irp, IO_NO_INCREMENT);

  00009	33 d2		 xor	 edx, edx
  0000b	48 8b cb	 mov	 rcx, rbx
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest

; 194  : 	return Irp->IoStatus.Status;

  00014	8b 43 30	 mov	 eax, DWORD PTR [rbx+48]

; 195  : }

  00017	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001b	5b		 pop	 rbx
  0001c	c3		 ret	 0
CreateDispatch ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File c:\users\finn\documents\github\hardware_spoofer\disk\main.c
;	COMDAT UnsupportedDispatch
_TEXT	SEGMENT
DeviceObject$ = 48
Irp$ = 56
UnsupportedDispatch PROC				; COMDAT

; 178  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b da	 mov	 rbx, rdx

; 179  : 	UNREFERENCED_PARAMETER(DeviceObject);
; 180  : 
; 181  : 	Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

  00009	c7 42 30 bb 00
	00 c0		 mov	 DWORD PTR [rdx+48], -1073741637 ; ffffffffc00000bbH

; 182  : 	IoCompleteRequest(Irp, IO_NO_INCREMENT);

  00010	48 8b cb	 mov	 rcx, rbx
  00013	33 d2		 xor	 edx, edx
  00015	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_IofCompleteRequest

; 183  : 	return Irp->IoStatus.Status;

  0001b	8b 43 30	 mov	 eax, DWORD PTR [rbx+48]

; 184  : }

  0001e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00022	5b		 pop	 rbx
  00023	c3		 ret	 0
UnsupportedDispatch ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File c:\users\finn\documents\github\hardware_spoofer\disk\main.c
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\km\wdm.h
; File c:\users\finn\documents\github\hardware_spoofer\disk\main.c
;	COMDAT DiskDriverDispatch
_TEXT	SEGMENT
DeviceObject$ = 48
Irp$ = 56
DiskDriverDispatch PROC					; COMDAT

; 125  : {

$LN12:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\km\wdm.h

; 30868:     return Irp->Tail.Overlay.CurrentStackLocation;

  00014	48 8b ba b8 00
	00 00		 mov	 rdi, QWORD PTR [rdx+184]
; File c:\users\finn\documents\github\hardware_spoofer\disk\main.c

; 125  : {

  0001b	48 8b f2	 mov	 rsi, rdx
  0001e	48 8b e9	 mov	 rbp, rcx

; 126  : 	PIO_STACK_LOCATION Io = IoGetCurrentIrpStackLocation(Irp);
; 127  : 
; 128  : 	switch (Io->Parameters.DeviceIoControl.IoControlCode)

  00021	8b 47 18	 mov	 eax, DWORD PTR [rdi+24]
  00024	3d 88 c0 07 00	 cmp	 eax, 508040		; 0007c088H
  00029	74 4b		 je	 SHORT $LN6@DiskDriver
  0002b	3d 00 14 2d 00	 cmp	 eax, 2954240		; 002d1400H
  00030	75 73		 jne	 SHORT $LN2@DiskDriver

; 129  : 	{
; 130  : 	case IOCTL_STORAGE_QUERY_PROPERTY:
; 131  : 	{
; 132  : 		PSTORAGE_PROPERTY_QUERY query = (PSTORAGE_PROPERTY_QUERY)Irp->AssociatedIrp.SystemBuffer;
; 133  : 
; 134  : 		if (query->PropertyId == StorageDeviceProperty)

  00032	48 8b 42 18	 mov	 rax, QWORD PTR [rdx+24]
  00036	83 38 00	 cmp	 DWORD PTR [rax], 0
  00039	75 6a		 jne	 SHORT $LN2@DiskDriver

; 135  : 		{
; 136  : 			Io->Control = 0;
; 137  : 			Io->Control |= SL_INVOKE_ON_SUCCESS;
; 138  : 
; 139  : 			PVOID OldContext = Io->Context;

  0003b	48 8b 5f 40	 mov	 rbx, QWORD PTR [rdi+64]

; 140  : 			Io->Context = (PVOID)ExAllocatePool(NonPagedPool, sizeof(REQUEST_STRUCT));

  0003f	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00044	33 c9		 xor	 ecx, ecx
  00046	c6 47 03 40	 mov	 BYTE PTR [rdi+3], 64	; 00000040H
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePool

; 141  : 			REQUEST_STRUCT *pRequest = (REQUEST_STRUCT*)Io->Context;
; 142  : 			pRequest->OldRoutine = Io->CompletionRoutine;

  00050	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  00054	48 89 47 40	 mov	 QWORD PTR [rdi+64], rax
  00058	48 89 08	 mov	 QWORD PTR [rax], rcx

; 143  : 			pRequest->OldContext = OldContext;

  0005b	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx

; 144  : 			pRequest->OutputBufferLength = Io->Parameters.DeviceIoControl.OutputBufferLength;

  0005f	8b 4f 08	 mov	 ecx, DWORD PTR [rdi+8]
  00062	89 48 10	 mov	 DWORD PTR [rax+16], ecx

; 145  : 			pRequest->StorageDescriptor = (PSTORAGE_DEVICE_DESCRIPTOR)Irp->AssociatedIrp.SystemBuffer;

  00065	48 8b 4e 18	 mov	 rcx, QWORD PTR [rsi+24]
  00069	48 89 48 18	 mov	 QWORD PTR [rax+24], rcx

; 146  : 
; 147  : 			Io->CompletionRoutine = (PIO_COMPLETION_ROUTINE)StorageQueryCompletionRoutine;

  0006d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:StorageQueryCompletionRoutine

; 148  : 		}
; 149  : 
; 150  : 		break;

  00074	eb 2b		 jmp	 SHORT $LN10@DiskDriver
$LN6@DiskDriver:

; 151  : 
; 152  : 	}
; 153  : 
; 154  : 	case SMART_RCV_DRIVE_DATA:
; 155  : 	{
; 156  : 		Io->Control = 0;
; 157  : 		Io->Control |= SL_INVOKE_ON_SUCCESS;
; 158  : 
; 159  : 		PVOID OldContext = Io->Context;

  00076	48 8b 5f 40	 mov	 rbx, QWORD PTR [rdi+64]

; 160  : 		Io->Context = (PVOID)ExAllocatePool(NonPagedPool, sizeof(REQUEST_STRUCT));

  0007a	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0007f	33 c9		 xor	 ecx, ecx
  00081	c6 47 03 40	 mov	 BYTE PTR [rdi+3], 64	; 00000040H
  00085	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExAllocatePool

; 161  : 		REQUEST_STRUCT *pRequest = (REQUEST_STRUCT*)Io->Context;
; 162  : 		pRequest->OldRoutine = Io->CompletionRoutine;

  0008b	48 8b 4f 38	 mov	 rcx, QWORD PTR [rdi+56]
  0008f	48 89 47 40	 mov	 QWORD PTR [rdi+64], rax
  00093	48 89 08	 mov	 QWORD PTR [rax], rcx

; 163  : 		pRequest->OldContext = OldContext;

  00096	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx

; 164  : 
; 165  : 		Io->CompletionRoutine = (PIO_COMPLETION_ROUTINE)SmartCompletionRoutine;

  0009a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:SmartCompletionRoutine
$LN10@DiskDriver:

; 166  : 
; 167  : 		break;
; 168  : 	}
; 169  : 	}
; 170  : 
; 171  : 	return RealDiskDeviceControl(DeviceObject, Irp);

  000a1	48 89 47 38	 mov	 QWORD PTR [rdi+56], rax
$LN2@DiskDriver:
  000a5	48 8b d6	 mov	 rdx, rsi
  000a8	48 8b cd	 mov	 rcx, rbp

; 172  : }

  000ab	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000b0	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  000b5	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000ba	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000be	5f		 pop	 rdi

; 166  : 
; 167  : 		break;
; 168  : 	}
; 169  : 	}
; 170  : 
; 171  : 	return RealDiskDeviceControl(DeviceObject, Irp);

  000bf	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR RealDiskDeviceControl
DiskDriverDispatch ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File c:\users\finn\documents\github\hardware_spoofer\disk\main.c
;	COMDAT SmartCompletionRoutine
_TEXT	SEGMENT
DeviceObject$ = 48
Irp$ = 56
Context$ = 64
SmartCompletionRoutine PROC				; COMDAT

; 105  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b da	 mov	 rbx, rdx

; 106  : 	UNREFERENCED_PARAMETER(DeviceObject);
; 107  : 
; 108  : 	PIO_COMPLETION_ROUTINE OldCompletionRoutine = NULL;
; 109  : 	PVOID OldContext = NULL;
; 110  : 
; 111  : 	if (Context != NULL)

  00009	4d 85 c0	 test	 r8, r8
  0000c	74 0b		 je	 SHORT $LN2@SmartCompl

; 112  : 	{
; 113  : 		REQUEST_STRUCT* pRequest = (REQUEST_STRUCT*)Context;
; 114  : 		OldCompletionRoutine = pRequest->OldRoutine;
; 115  : 		OldContext = pRequest->OldContext;
; 116  : 		ExFreePool(Context);

  0000e	33 d2		 xor	 edx, edx
  00010	49 8b c8	 mov	 rcx, r8
  00013	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag
$LN2@SmartCompl:

; 117  : 	}
; 118  : 
; 119  : 	Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

  00019	b8 bb 00 00 c0	 mov	 eax, -1073741637	; ffffffffc00000bbH
  0001e	89 43 30	 mov	 DWORD PTR [rbx+48], eax

; 120  : 
; 121  : 	return Irp->IoStatus.Status;
; 122  : }

  00021	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00025	5b		 pop	 rbx
  00026	c3		 ret	 0
SmartCompletionRoutine ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File c:\users\finn\documents\github\hardware_spoofer\disk\main.c
;	COMDAT StorageQueryCompletionRoutine
_TEXT	SEGMENT
DeviceObject$ = 64
Irp$ = 72
Context$ = 80
StorageQueryCompletionRoutine PROC			; COMDAT

; 74   : {

$LN7:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	41 56		 push	 r14
  00012	41 57		 push	 r15
  00014	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00018	48 8b da	 mov	 rbx, rdx
  0001b	4c 8b f1	 mov	 r14, rcx

; 75   : 	PIO_COMPLETION_ROUTINE OldCompletionRoutine = NULL;
; 76   : 	PVOID OldContext = NULL;
; 77   : 	ULONG OutputBufferLength = 0;
; 78   : 	PSTORAGE_DEVICE_DESCRIPTOR descriptor = NULL;
; 79   : 
; 80   : 	if (Context != NULL)

  0001e	4d 85 c0	 test	 r8, r8
  00021	74 4b		 je	 SHORT $LN4@StorageQue

; 81   : 	{
; 82   : 		REQUEST_STRUCT* pRequest = (REQUEST_STRUCT*)Context;
; 83   : 		OldCompletionRoutine = pRequest->OldRoutine;

  00023	49 8b 38	 mov	 rdi, QWORD PTR [r8]

; 84   : 		OldContext = pRequest->OldContext;
; 85   : 		OutputBufferLength = pRequest->OutputBufferLength;
; 86   : 		descriptor = pRequest->StorageDescriptor;
; 87   : 
; 88   : 		ExFreePool(Context);

  00026	33 d2		 xor	 edx, edx
  00028	4d 8b 78 08	 mov	 r15, QWORD PTR [r8+8]
  0002c	49 8b c8	 mov	 rcx, r8
  0002f	41 8b 68 10	 mov	 ebp, DWORD PTR [r8+16]
  00033	49 8b 70 18	 mov	 rsi, QWORD PTR [r8+24]
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ExFreePoolWithTag

; 89   : 	}
; 90   : 
; 91   : 	if (FIELD_OFFSET(STORAGE_DEVICE_DESCRIPTOR, SerialNumberOffset) < OutputBufferLength && descriptor->SerialNumberOffset > 0 && descriptor->SerialNumberOffset < OutputBufferLength)

  0003d	83 fd 18	 cmp	 ebp, 24
  00040	76 14		 jbe	 SHORT $LN3@StorageQue
  00042	8b 46 18	 mov	 eax, DWORD PTR [rsi+24]
  00045	85 c0		 test	 eax, eax
  00047	74 0d		 je	 SHORT $LN3@StorageQue
  00049	3b c5		 cmp	 eax, ebp
  0004b	73 09		 jae	 SHORT $LN3@StorageQue

; 92   : 	{
; 93   : 		char* SerialNumber = ((char*)descriptor) + descriptor->SerialNumberOffset;

  0004d	48 8d 0c 06	 lea	 rcx, QWORD PTR [rsi+rax]

; 94   : 
; 95   : 		SpoofSerialNumber(SerialNumber);

  00051	e8 00 00 00 00	 call	 SpoofSerialNumber
$LN3@StorageQue:

; 96   : 	}
; 97   : 
; 98   : 	if ((Irp->StackCount >(ULONG)1) && (OldCompletionRoutine != NULL))

  00056	48 85 ff	 test	 rdi, rdi
  00059	74 13		 je	 SHORT $LN4@StorageQue
  0005b	80 7b 42 01	 cmp	 BYTE PTR [rbx+66], 1
  0005f	76 0d		 jbe	 SHORT $LN4@StorageQue

; 99   : 		return OldCompletionRoutine(DeviceObject, Irp, OldContext);

  00061	4d 8b c7	 mov	 r8, r15
  00064	48 8b d3	 mov	 rdx, rbx
  00067	49 8b ce	 mov	 rcx, r14
  0006a	ff d7		 call	 rdi
  0006c	eb 02		 jmp	 SHORT $LN1@StorageQue
$LN4@StorageQue:

; 100  : 
; 101  : 	return STATUS_SUCCESS;

  0006e	33 c0		 xor	 eax, eax
$LN1@StorageQue:

; 102  : }

  00070	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00075	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
  0007a	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  0007f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00083	41 5f		 pop	 r15
  00085	41 5e		 pop	 r14
  00087	5f		 pop	 rdi
  00088	c3		 ret	 0
StorageQueryCompletionRoutine ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File c:\users\finn\documents\github\hardware_spoofer\disk\main.c
;	COMDAT SpoofSerialNumber
_TEXT	SEGMENT
serialNumber$ = 64
Seed$1 = 72
SpoofSerialNumber PROC					; COMDAT

; 45   : {

$LN19:
  00000	48 8b c4	 mov	 rax, rsp
  00003	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00007	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0000b	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  0000f	41 54		 push	 r12
  00011	41 56		 push	 r14
  00013	41 57		 push	 r15
  00015	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 46   : 	if (!HWIDGenerated)

  00019	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR HWIDGenerated, 0
  00020	48 8b f9	 mov	 rdi, rcx
  00023	0f 85 d3 00 00
	00		 jne	 $LN5@SpoofSeria

; 47   : 	{
; 48   : 		HWIDGenerated = 1;
; 49   : 
; 50   : 		LARGE_INTEGER Seed;
; 51   : 		KeQuerySystemTimePrecise(&Seed);

  00029	48 8d 48 10	 lea	 rcx, QWORD PTR [rax+16]
  0002d	c7 05 00 00 00
	00 01 00 00 00	 mov	 DWORD PTR HWIDGenerated, 1
  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_KeQuerySystemTimePrecise

; 52   : 
; 53   : 		for (int i = 0; i < strlen(SpoofedHWID); ++i)

  0003d	33 f6		 xor	 esi, esi
  0003f	4c 8d 35 00 00
	00 00		 lea	 r14, OFFSET FLAT:SpoofedHWID
  00046	49 83 cf ff	 or	 r15, -1
  0004a	49 8b c7	 mov	 rax, r15
$LL17@SpoofSeria:
  0004d	48 ff c0	 inc	 rax
  00050	41 38 34 06	 cmp	 BYTE PTR [r14+rax], sil
  00054	75 f7		 jne	 SHORT $LL17@SpoofSeria
  00056	48 85 c0	 test	 rax, rax
  00059	0f 84 81 00 00
	00		 je	 $LN3@SpoofSeria
  0005f	49 8b de	 mov	 rbx, r14
  00062	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:NumTable
$LL4@SpoofSeria:

; 54   : 		{
; 55   : 
; 56   : 			if (SpoofedHWID[i] == 'Y')

  00069	44 8a 03	 mov	 r8b, BYTE PTR [rbx]
  0006c	41 80 f8 59	 cmp	 r8b, 89			; 00000059H
  00070	75 26		 jne	 SHORT $LN13@SpoofSeria

; 57   : 			{
; 58   : 				SpoofedHWID[i] = RtlRandomEx(&Seed.LowPart) % 26 + 65;

  00072	48 8d 4c 24 48	 lea	 rcx, QWORD PTR Seed$1[rsp]
  00077	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlRandomEx
  0007d	44 8b c0	 mov	 r8d, eax
  00080	b8 4f ec c4 4e	 mov	 eax, 1321528399		; 4ec4ec4fH
  00085	41 f7 e0	 mul	 r8d
  00088	c1 ea 03	 shr	 edx, 3
  0008b	6b ca 1a	 imul	 ecx, edx, 26
  0008e	44 2b c1	 sub	 r8d, ecx
  00091	41 80 c0 41	 add	 r8b, 65			; 00000041H
  00095	44 88 03	 mov	 BYTE PTR [rbx], r8b
$LN13@SpoofSeria:

; 59   : 
; 60   : 			}
; 61   : 
; 62   : 			if (SpoofedHWID[i] == 'X')

  00098	41 80 f8 58	 cmp	 r8b, 88			; 00000058H
  0009c	75 28		 jne	 SHORT $LN2@SpoofSeria

; 63   : 			{
; 64   : 				SpoofedHWID[i] = NumTable[RtlRandomEx(&Seed.LowPart) % (strlen(NumTable) - 1)];

  0009e	48 8d 4c 24 48	 lea	 rcx, QWORD PTR Seed$1[rsp]
  000a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_RtlRandomEx
  000a9	8b c0		 mov	 eax, eax
  000ab	49 8b cf	 mov	 rcx, r15
$LL16@SpoofSeria:
  000ae	48 ff c1	 inc	 rcx
  000b1	41 80 3c 0c 00	 cmp	 BYTE PTR [r12+rcx], 0
  000b6	75 f6		 jne	 SHORT $LL16@SpoofSeria
  000b8	48 ff c9	 dec	 rcx
  000bb	33 d2		 xor	 edx, edx
  000bd	48 f7 f1	 div	 rcx
  000c0	42 8a 04 22	 mov	 al, BYTE PTR [rdx+r12]
  000c4	88 03		 mov	 BYTE PTR [rbx], al
$LN2@SpoofSeria:

; 52   : 
; 53   : 		for (int i = 0; i < strlen(SpoofedHWID); ++i)

  000c6	ff c6		 inc	 esi
  000c8	49 8b cf	 mov	 rcx, r15
  000cb	48 ff c3	 inc	 rbx
$LL15@SpoofSeria:
  000ce	48 ff c1	 inc	 rcx
  000d1	41 80 3c 0e 00	 cmp	 BYTE PTR [r14+rcx], 0
  000d6	75 f6		 jne	 SHORT $LL15@SpoofSeria
  000d8	48 63 c6	 movsxd	 rax, esi
  000db	48 3b c1	 cmp	 rax, rcx
  000de	72 89		 jb	 SHORT $LL4@SpoofSeria
$LN3@SpoofSeria:

; 65   : 			}
; 66   : 		}
; 67   : 
; 68   : 		RtlCopyMemory((void*)serialNumber, (void*)SpoofedHWID, 21);

  000e0	0f 10 05 00 00
	00 00		 movups	 xmm0, XMMWORD PTR SpoofedHWID
  000e7	0f 11 07	 movups	 XMMWORD PTR [rdi], xmm0
  000ea	8b 05 10 00 00
	00		 mov	 eax, DWORD PTR SpoofedHWID+16
  000f0	89 47 10	 mov	 DWORD PTR [rdi+16], eax
  000f3	8a 05 14 00 00
	00		 mov	 al, BYTE PTR SpoofedHWID+20
  000f9	88 47 14	 mov	 BYTE PTR [rdi+20], al
$LN5@SpoofSeria:

; 69   : 	}
; 70   : 	return STATUS_SUCCESS;
; 71   : }

  000fc	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00101	33 c0		 xor	 eax, eax
  00103	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  00108	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  0010d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00111	41 5f		 pop	 r15
  00113	41 5e		 pop	 r14
  00115	41 5c		 pop	 r12
  00117	c3		 ret	 0
SpoofSerialNumber ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File c:\users\finn\documents\github\hardware_spoofer\disk\main.c
;	COMDAT GetDriverObject
_TEXT	SEGMENT
DriverName$ = 80
DrvObject$ = 88
GetDriverObject PROC					; COMDAT

; 31   : {

$LN5:
  00000	4c 8b dc	 mov	 r11, rsp
  00003	53		 push	 rbx
  00004	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 32   : 	PDRIVER_OBJECT DrvObject;
; 33   : 	if (NT_SUCCESS(ObReferenceObjectByName(DriverName, 0, NULL, 0, *IoDriverObjectType, KernelMode, NULL, &DrvObject)))

  00008	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_IoDriverObjectType
  0000f	49 8d 53 10	 lea	 rdx, QWORD PTR [r11+16]
  00013	49 89 53 f0	 mov	 QWORD PTR [r11-16], rdx
  00017	33 db		 xor	 ebx, ebx
  00019	49 89 5b e8	 mov	 QWORD PTR [r11-24], rbx
  0001d	45 33 c9	 xor	 r9d, r9d
  00020	88 5c 24 28	 mov	 BYTE PTR [rsp+40], bl
  00024	45 33 c0	 xor	 r8d, r8d
  00027	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002a	33 d2		 xor	 edx, edx
  0002c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002f	49 89 43 d8	 mov	 QWORD PTR [r11-40], rax
  00033	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ObReferenceObjectByName
  00039	85 c0		 test	 eax, eax
  0003b	48 0f 49 5c 24
	58		 cmovns	 rbx, QWORD PTR DrvObject$[rsp]
  00041	48 8b c3	 mov	 rax, rbx

; 34   : 	{
; 35   : 		return DrvObject;
; 36   : 	}
; 37   : 
; 38   : 	return NULL;
; 39   : }

  00044	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
GetDriverObject ENDP
_TEXT	ENDS
; Function compile flags: /Ogsp
; File c:\program files (x86)\windows kits\10\include\10.0.17134.0\km\wdm.h
;	COMDAT IoGetCurrentIrpStackLocation
_TEXT	SEGMENT
Irp$ = 8
IoGetCurrentIrpStackLocation PROC			; COMDAT

; 30867:     NT_ASSERT(Irp->CurrentLocation <= Irp->StackCount + 1);
; 30868:     return Irp->Tail.Overlay.CurrentStackLocation;

  00000	48 8b 81 b8 00
	00 00		 mov	 rax, QWORD PTR [rcx+184]

; 30869: }

  00007	c3		 ret	 0
IoGetCurrentIrpStackLocation ENDP
_TEXT	ENDS
END
